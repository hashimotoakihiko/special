3 - PHP基礎3

PHPに限らずプログラム言語にはオブジェクトという概念と、クラスという仕組みがあります。
プログラムを書いていると、関連する変数や関数をひとまとめにしておき、使いまわしたい場面が出てく
るでしょう。
クラスには様々な変数および定数( property , プロパティ)や関数( method , メソッド)を定義し、
関連の処理をひとまとめにしておくことができます。

3-1  基本的なクラスの定義方法

    クラスは次のように定義し、インスタンス生成します。 クラスはインスタンス生成(実体化)すること定義
    したものを使いまわすことができます。
    //=================コード====================
    # クラス定義
    class クラス名
    {
    # プロパティ
    # メソッド
    }
    # インスタンス生成
    $sample = new クラス名();
    //=================コード====================
    クラス名(例の class Sample の部分)は一文字目は大文字にする、アクセス修飾子を必ず書く等のルー
    ルがあります。
    ソースコードに目を通したら、まずは例に沿って書いて行きましょう。

    //=================コード====================
    # クラス名の一文字目は大文字にします
    class Sample
    {
    # publicはアクセス修飾子のこと(後述)
    public $sampleProperty1;
    # プロパティは複数設定することができます
    public $sampleProperty2;
    
    # アクセス修飾子 function 関数名()
    public function sampleMethod1()
    {
    // 処理
    }
    
    # メソッドも複数作成可能です
    public function sampleMethod2()
    {
    # 処理
    }
    }
    $sample = new Sample();
    //=================コード====================
    クラスのプロパティには初期値を設定することができます。
    これもfunctionの項で行った説明同様に、初期値を必ず設定する必要があるのか判断して設定しましょう。
    //=================コード====================
    class Sample
    {
    public $name = '太郎';
    public $age = 10;
    public $country = 'アメリカ合衆国';
    }
    //=================コード====================

    クラスのインスタンス生成とプロパティへのアクセス
    プログラミング言語においてクラスはいわば設計図のようなものです。
    例外もありますが、基本的にクラスは new キーワードを利用してインスタンスを生成し、実体化する必
    要があります。
    また、作成したインスタンス毎にプロパティの値を変更するなどできます。

    インスタンス生成
    次の例では、Sampleクラスを定義し、 $sample にインスタンス生成し、
    実体化されたオブジェクト型の値を変数に代入(以降、オブジェクト変数)しています。

    //=================コード====================
    # クラスの定義
    class Sample
    {
    public $name = '太郎';
    }
    # インスタンス生成
    $sample = new Sample();
    # objectをvar_dump()すると、次のようになります
    var_dump($sample);
    /*
    出力結果)
    object(Sample)#1 (1) {
    ["name"]=>
    string(6) "太郎"
    }
    */
    //=================コード====================

    プロパティへのアクセス
    オブジェクト変数と、プロパティの間に -> (アロー演算子, arrow operator)を繋いで記述すると、
    オブジェクト変数からプロパティにアクセスすることができます。

    //=================コード====================
    class Sample
    {
    public $name = '太郎';
    }
    $sample = new Sample();
    # $nameプロパティを出力します
    echo $sample->name;
    # 出力結果) 太郎
    # $nameプロパティの上書きします
    $sample->name = '花子';
    var_dump($sample->name);
    # 出力結果) string(6) "花子"
    //=================コード====================

    インスタンスとは
    インスタンスは、作成する毎に固有の状態(属性という)を持ちます。
    次の例のように、 new キーワードを使って作成されたインスタンスは、それぞれに異なるプロパティの
    状態を保持することができます。

    class Sample
    {
    public $name;
    }

    # $sample1にSampleクラスのインスタンスを代入し、nameプロパティに値を代入します。
    $sample1 = new Sample();
    $sample1->name = '太郎';
    # $sample2にSampleクラスのインスタンスを代入し、nameプロパティに値を代入します。
    $sample2 = new Sample();
    $sample2->name = '花子';
    # $sample1, $sample2のnameにそれぞれ異なる値を保持することができます。
    echo $sample1->name . '<br>';
    echo $sample2->name;
    /*
    出力結果)
    太郎
    花子
    */

3-2 メソッドの利用
    クラスにはメソッド(振る舞いともいう)と呼ばれる関数を作成することができます。
    主な役割として、プロパティへアクセスしたり、クラスに関する固有の情報を表示するなどしています。

    メソッドの定義方法
    メソッドはプロパティ同様に、 アクセス修飾子 を設定しますが、それ以降は function で説明したも
    のと同様のルールで記述して行きます。 オブジェクト変数からのメソッドへのアクセスもプロパティ同様
    に、 -> を利用します。

    //=================コード====================
    class Sample
    {
    # メソッドの定義
    public function showMessage($message)
    {
    echo $message;
    }
    }
    $sample = new Sample();
    # メソッドの呼び出します
    $sample->showMessage('Hello');
    # 出力結果) Hello
    //=================コード====================
    クラス内のメソッドから、別のメソッドやプロパティにアクセスしたい場合は擬似変数 $this を利用し
    ます。
    $this は再代入できない特殊な変数で、個別のインスタンス自身を指します。
    //=================コード====================
    class Sample
    {
    public $name;
    public $age;
    
    public function showName()
    {
    # 次のようにプロパティにアクセスします
    echo '名前: ' . $this->name . '<br>';
    }
    
    public function showAge()
    {
    echo '年齢: ' . $this->age . '歳<br>';
    }
    
    public function showProperties()
    {
    # メソッドの呼び出し
    $this->showName();
    $this->showAge();
    echo '<br>';
    }
    }
    $sample1 = new Sample();
    $sample1->name = '太郎';
    $sample1->age = 10;
    $sample2 = new Sample();
    $sample2->name = '花子';
    $sample2->age = 11;
    # オブジェクト変数からのメソッドへのアクセスはプロパティ同様「->」で繋いで呼び出します
    $sample1->showProperties();
    $sample2->showProperties();
    /*
    出力結果)
    名前: 太郎
    年齢: 10歳
    名前: 花子
    年齢: 11歳
    */
    //=================コード====================


コンストラクター
今まで述べてきたように、インスタンス生成後に様々な操作を行うことができるが、クラスを扱っている
と、
プロパティの値セットや、特定のメソッドの実行をインスタンス生成時に行いたいと思うケースが出てき
ます。
PHPでは、 __construct というメソッドを作成することで、インスタンス生成時に行いたい操作をひ
とまとめにすることができます。

    //=================コード====================
    class Sample
    {
    public $name;
    
    public function __construct($name)
    {
    echo 'インスタンスを生成しました。<br>';
    $this->name = $name;
    }
    
    public function showName()
    {
    echo '名前: ' $this->name . '<br>';
    }
    }
    $sample = new Sample('太郎');
    $sample->showName();
    /*
    出力結果)
    インスタンスを生成しました。
    名前: 太郎
    */
    //=================コード====================
    注意点として、他の言語で行えるような、クラス名と同名のコンストラクターは推奨されていません。
    将来のバージョンで削除される予定の機能なので、利用しないようにしましょう。

    //=================コード====================
    class Sample
    {
    // 非推奨のmethod名です
    public function sample()
    {
    
    }
    }
    //=================コード====================

    3-3 アクセス修飾子

    今までクラスのプロパティやメソッドの先頭に public というキーワードをつけてきましたが、
    他にも private , protected があり、これらはアクセス修飾子とよばれ、適切にアクセスを制限しな
    くてはなりません。
    それではおさらいも兼ねて、順に説明していきます。後述のカプセル化を行うために必須な知識なので、
    良く確認しておきましょう。

    public
    今まで通りにアクセス修飾子を public とすると、どこからでもアクセスすることができます。

    //=================コード====================
    class A
    {
    public $b;
    public function c()
    {
    echo $this->a;
    }
    }
    $a = new A();
    $a->b = 'b';
    $a->c();
    # 出力結果) b
    //=================コード====================

    private
    アクセス修飾子を private にすると、いかなる場合もクラス内からしかプロパティ、メソッドにアクセ
    スできなくなります。
    自身のクラス内で $this を利用してのアクセスのみ許されます。
    まず、次のアクセスはエラーとなる。

    //=================コード====================
    class A
    {
    private $b;
    private function c()
    {
    echo $this->b;
    }
    
    }
    $a = new A();
    # これは進行不能なエラー(Fatal Error)となります
    $a->b = 'b';
    # これも進行不能なエラー(Fatal Error)となります
    $a->c();
    # 出力結果) Uncaught Error: Cannot access private property A::$b
    /*
    補足)
    $a->b()で進行不能のエラーとなるため1つしか出力されませんが、
    $a->c();も次のようなエラーメッセージが出力されます
    Uncaught Error: Call to private method A::c()
    */
    //=================コード====================

    上記の問題があるため、通常はプロパティだけを private とし、メソッドからプロパティを呼び出して
    処理を行います
    その際、メソッドのアクセス修飾子は public とします。

    //=================コード====================
    class A
    {
    private $b = 'b';
    public function c()
    {
    echo $this->b;
    }
    }
    $a = new A();
    $a->c();
    # 出力結果) b
    //=================コード====================

    protected
    アクセス修飾子を protected とすると、 private 同様に protected と指定したプロパティ・メソ
    ッドに対して、外部からアクセスすることができなくなります。
    private と違い、継承(後述)を行った場合に、継承したクラス内でも $this を使ってアクセスするこ
    とができます。
    まずは例を見て行きましょう。
    protected アクセス修飾子はクラス内および、継承先のクラス(サブクラス)からのみアクセスが可能で
    す。
    private の時同様、次のアクセスはアクセス権限がない箇所からのアクセスとなるため、エラーになり
    ます。

    //=================コード====================
    class A
    {
    protected $b = 'b';
    protected function c()
    {
    echo $this->b;
    }
    }
    $a = new A();
    # これは進行不能なエラー(Fatal Error)となります
    echo $a->b;
    # これも進行不能なエラー(Fatal Error)となります
    echo $a->c();
    # 出力結果) Fatal error: Uncaught Error: Cannot access protected property A::$b
    /*
    補足) 
    $a->b()で進行不能のエラーとなるため1つしか出力されませんが、
    $a->c();も次のようなエラーメッセージが出力されます
    Fatal error: Uncaught Error: Call to protected method A::c() 
    */
    //=================コード====================

    private 同様に一般的に、 protected を利用する場合は、クラス内のメソッドでフィールドを使っ
    た処理を行います。
    メソッドのアクセス修飾子は private の時と同じく public としましょう。

    //=================コード====================
    class A
    {
    protected $b = 'b';
    public function c()
    {
    echo $this->b;
    }
    }
    $a = new A();
    $a->c();
    # 出力結果) b
    //=================コード====================

    継承について、詳しくは改めて説明しますが、
    継承したクラス(サブクラス)内でもフィールドにアクセスすることができます。
    サブクラスでのみメソッド、フィールドにアクセスする場合は、継承元(スーパークラス)のメソッドのア
    クセス修飾子も protected にしましょう。

    //=================コード====================
    class A
    {
    protected $a1 = 'a1';
    protected function a2()
    {
    echo 'a2';
    }
    }
    class B extends A
    {
    public function b1()
    {
    echo $this->a1 . '<br>';
    }
    public function b2()
    {
    $this->a2() . '<br>';
    }
    }
    $b = new B();
    $b->b1();
    $b->b2();
    # これは進行不能なエラー(Fatal Error)となります
    echo $b->a1;
    /*
    出力結果)
    a1
    a2
    Fatal error: Uncaught Error: Cannot access protected property B::$a1
    */
    //=================コード====================